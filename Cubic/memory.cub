/##################

###################
# USE CASE 1
#
# Creating a custom allocator / Reinterpreting raw bytes
###################
struct Block {
  size_t size;
};

size_t size = 4096;
Block* block = malloc(sizeof(Block) + size);
block->size = size;
block->memory = (char*)block + sizeof(Block);


###################
# USE CASE 2
#
# Co-locating multiple arrays.
###################
struct Mesh {
  int num_verts;
  Vec3* pos;
  Vec3* norms;
  Vec2* uvs;
};

int num_verts = 100;
Mesh* mesh = malloc(sizeof(Mesh) + num_verts * (sizeof(Vec3) + sizeof(Vec3) + sizeof(Vec2)));
mesh->pos   = (char*)mesh + sizeof(Mesh);
mesh->norms = (char*)mesh + sizeof(Mesh) + num_verts * sizeof(Vec3);
mesh->uvs   = (char*)mesh + sizeof(Mesh) + num_verts * (sizeof(Vec3) + sizeof(Vec3));


###################
# USE CASE 3
#
# Should you free or not free memory from an API? Whos owns the memory?
###################

struct Foo_* foo_create();

struct Foo_* f = foo_create();

// free(f)?
// not free(f)?
// foo_destroy(f)?


###################
# USE CASE 4
#
# Who should free memory in structs?
###################

struct A {
  int* arr;
};

A a;
a.arr = calloc(10, sizeof(int));

free(A);  // leaks a.arr

Categories:
  - Reinterpreting bytes 
  - Colocating arrays
  - Memory Ownership (out of scope then free)

##################/

struct Vec3
  x: int
  y: int
  z: int
end

struct Body
  pos: Vec3*
  vel: Vec3
end

# *  --- Non-null raw Pointer
# !  --- unique pointer
# &  --- shared pointer (ref counted)
# (nothing) --- co-located member


do
  let b: Body = Body(pos=new Vec3(0, 0, 0), vel=new Vec3(0, 0, 0))

  let b_ptr: Body*  = &b
  let b_shd: Body&  = &b # ERROR: cannot create shared pointer to stack var
  let b_unq: Body!  = &b # ERROR: cannot create unique pointer to stack var
end

# & := address of operator
# * := dereferencing operator

variable = assignee
variable, assignee, method
---     , ---     , copies value
---     , *       , ERROR: non-pointer cannot take value of pointer
---     , !       , ERROR: non-pointer cannot take value of pointer
---     , &       , ERROR: non-pointer cannot take value of pointer

*       , ---     , sets variable to assignee
*       , *       , sets variable to assignee
*       , !       , borrows ownership, weak reference
*       , &       , borrows ownership, weak reference

&       , ---     , ERROR: shared ptr cannot be assigned to a raw location
&       , *       , moves ownership of assignee to variable
&       , !       , moves ownership of assignee to variable
&       , &       , borrows ownership, strong reference

!       , ---     , ERROR: unique ptr cannot be assigned to a raw location
!       , *       , moves ownership of assignee to variable
!       , !       , moves ownership of assignee to variable
!       , &       , ERROR: Unique ptr cannot borrow from shared ptr

*variable, method
---      , ERROR: Cannot dereference a non-pointer
*        , Copies pointed to value
&        , Copies pointed to value
!        , Copies pointed to value



Equivalent(
  'ref' Id ':' '=' Id,
  'let' Id ':' Type '&' '=' '&' Id)

Equivalent(
  'ptr' Id ':' '=' Id,
  'let' Id ':' Type '*' '=' '&' Id)

Equivalent(
  'unq' Id ':' '=' Id,
  'let' Id ':' Type '!' '=' '&' Id)

# Creates a Vec3 on the stack.
let pos_on_stack: Vec3 = (1, 2, 3)

# Creates a Vec3 on the heap.
let pos_on_heap* := (1, 2, 3)

ref pos_from_ref := pos_on_heap


function del_vec(v: Vec3&) do
end


struct Vec3
  x, y, z: float
end

entity Ball
  pos: Vec3
  vel: Vec3
end

let ball_pen: Arena[Ball] = ()

for b in Ball do
  pass
end

for b in ball_pen do
end