/##################

###################
# USE CASE 1
#
# Creating a custom allocator / Reinterpreting raw bytes
###################
struct Block {
  size_t size;
};

size_t size = 4096;
Block* block = malloc(sizeof(Block) + size);
block->size = size;
block->memory = (char*)block + sizeof(Block);


###################
# USE CASE 2
#
# Co-locating multiple arrays.
###################
struct Mesh {
  int num_verts;
  Vec3* pos;
  Vec3* norms;
  Vec2* uvs;
};

int num_verts = 100;
Mesh* mesh = malloc(sizeof(Mesh) + num_verts * (sizeof(Vec3) + sizeof(Vec3) + sizeof(Vec2)));
mesh->pos   = (char*)mesh + sizeof(Mesh);
mesh->norms = (char*)mesh + sizeof(Mesh) + num_verts * sizeof(Vec3);
mesh->uvs   = (char*)mesh + sizeof(Mesh) + num_verts * (sizeof(Vec3) + sizeof(Vec3));


###################
# USE CASE 3
#
# Should you free or not free memory from an API? Whos owns the memory?
###################

struct Foo_* foo_create();

struct Foo_* f = foo_create();

// free(f)?
// not free(f)?
// foo_destroy(f)?


###################
# USE CASE 4
#
# Who should free memory in structs?
###################

struct A {
  int* arr;
};

A a;
a.arr = calloc(10, sizeof(int));

free(A);  // leaks a.arr

Categories:
  - Reinterpreting bytes 
  - Colocating arrays
  - Memory Ownership (out of scope then free)

##################/

struct Vec3
  x: int
  y: int
  z: int
end

struct Body
  pos: Vec3*
  vel: Vec3
end

# *  --- Non-null raw Pointer
# !  --- unique pointer
# &  --- shared pointer (ref counted)
# (nothing) --- co-located member


do
  let b: Body = Body(pos=new Vec3(0, 0, 0), vel=new Vec3(0, 0, 0))

  let b_ptr: Body*  = &b
  let b_shd: Body&  = &b # ERROR: cannot create shared pointer to stack var
  let b_unq: Body!  = &b # ERROR: cannot create unique pointer to stack var
end

# & := address of operator
# * := dereferencing operator

let name: type = assignee
type    , assignee, method
---     , ---     , copies value
---     , *       , ERROR: non-pointer cannot take value of pointer
---     , !       , ERROR: non-pointer cannot take value of pointer
---     , &       , ERROR: non-pointer cannot take value of pointer

*       , ---     , sets variable to assignee
*       , *       , sets variable to assignee
*       , !       , borrows ownership, weak reference
*       , &       , borrows ownership, weak reference

&       , ---     , creates a new shared ptr copied from assignee
&       , *       , moves ownership of assignee to variable
&       , !       , moves ownership of assignee to variable
&       , &       , borrows ownership, strong reference

!       , ---     , creates a new unique ptr copied from assignee
!       , *       , moves ownership of assignee to variable
!       , !       , moves ownership of assignee to variable
!       , &       , ERROR: Unique ptr cannot borrow from shared ptr

variable = assignee
variable, assignee, method
---     , ---     , copies value
---     , *       , ERROR: non-pointer cannot take value of pointer
---     , !       , ERROR: non-pointer cannot take value of pointer
---     , &       , ERROR: non-pointer cannot take value of pointer

*       , ---     , sets variable to assignee
*       , *       , sets variable to assignee
*       , !       , borrows ownership, weak reference
*       , &       , borrows ownership, weak reference

&       , ---     , ERROR: shared ptr cannot be assigned to a raw location
&       , *       , moves ownership of assignee to variable
&       , !       , moves ownership of assignee to variable
&       , &       , borrows ownership, strong reference

!       , ---     , ERROR: unique ptr cannot be assigned to a raw location
!       , *       , moves ownership of assignee to variable
!       , !       , moves ownership of assignee to variable
!       , &       , ERROR: Unique ptr cannot borrow from shared ptr

*variable, method
---      , ERROR: Cannot dereference a non-pointer
*        , Copies pointed to value
&        , Copies pointed to value
!        , Copies pointed to value



Equivalent(
  'ref' Id ':' [Type] '=',
  'let' Id ':' Type '&' '='
  )

Equivalent(
  'ptr' Id ':' [Type] '=',
  'let' Id ':' Type '*' '='
  )

Equivalent(
  'unq' Id ':' [Type] '=',
  'let' Id ':' Type '!' '='
  )

# Creates a Vec3 on the stack.
let pos_on_stack: Vec3 = (1, 2, 3)

# Creates a Vec3 on the heap.
let pos_on_heap* := (1, 2, 3)

ref pos_from_ref := pos_on_heap


function del_vec(v: Vec3&) do
end


struct Vec3
  x, y, z: float
end

entity Ball
  pos: Vec3
  vel: Vec3
end

let ball_pen: Arena[Ball] = ()

for b in Ball do
  pass
end

for b in ball_pen do
end

let l : list[int] = [1, 2, 3]

fn sum(l : list[int]) -> int
  let accum := 0
  for i in l do
    accum += i
  end

  return accum
end

# OK, copies `l`
sum(l)


fn sum(l : list[int]*) -> int
  ...
end

# OK, creates a new weak reference to `l`
sum(l)

fn sum(l : list[int]&) -> int
  ...
end

# OK, creates a new shared reference to `l`
sum(l)

fn sum(l : list[int]!) -> int
  ...
end

# OK, creates a new unique reference to `l`

struct Bar
  a: int!
  b: string!
end

struct Foo
  bar: Bar!
end


let f : Foo = (Bar(1, 'a'))

function frobnicate(x: Foo)
  ...
end

# ERROR: 'Foo' is not copyable because 'Foo.bar' is not copyable.
frobnicate(f)

# OK: Creates a shared ptr `x` to f
function frobnicate(x: Foo&)

# OK: Creates a unique ptr `x` to f
function frobnicate(x: Foo!)

do
  let f : Foo = ...

  ref g := &f
  ptr i := &f
end

do
  let x: int = 5
  let y: int* = &x
  let z: int* = new int (5)
  let j := new int (5)
  let w: list[int] = new list[int] 
end